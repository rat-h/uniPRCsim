##################################
#
# clmodel.py 
# Copyright (C) Louisiana State University, Health Sciences Center
# Written by 2011-2013 Ruben Tikidji-Hamburyan <rth@nisms.krinc.ru>
#
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or (at
# your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
# NON INFRINGEMENT.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
###################################
import sys, csv
import random as rnd
from datetime import time
import clprc, clrprc, clpopulation, clneurons, clconnection, clnoisyneurons, clrepeaters

class clmodel:
	class file:
		def __init__(self,attr={}):
			self.format, self.watch, self.name, self.connections = "excel","last period","data.csv", "on"
			#### Test for implicit attributes:
			for atr in attr.keys():
				if atr == "format": continue
				if atr == "watch": continue
				if atr == "name": continue
				if atr == "connections": continue
				sys.stderr.write("Unexpected attribute \'%s\'for tag <output>\nABORT\n\n"%atr)
				sys.exit(1)
			if attr.get("format"):
				self.format = attr["format"]
			if attr.get("watch"):
				self.watch = attr["watch"]
			if attr.get("name"):
				self.name = attr["name"]
			if attr.get("connections"):
				self.connections = attr["connections"]

			if self.format == "xml":
				if self.name[-4:] != ".xml" :
					self.name += ".xml"
				self.__fd = open(self.name,"w")
				self.__fd.write("<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n")
				self.__fd.write("<!--Automatically generated by uniPRCsim-->\n")
				self.__fd.write("<!--     Version 0.01.01 (preAlpha)     -->\n")
				self.__fd.write("<data watch=\"%s\">\n"%self.watch)
			elif self.format == "data":
				if self.name[-4:] != ".dat" :
					self.name += ".dat"
				self.__fd = open(self.name,"w")
				self.__fd.write("###Automatically generated by uniPRCsim###\n")
				self.__fd.write("###     Version 0.01.01 (preAlpha)     ###\n")
				self.__fd.write("###       Watch % 18s     ###\n"%self.watch)
			else:
				if self.name[-4:] != ".csv" :
					self.name += ".csv"
				self.__hfd = open(self.name,"w")
				self.__fd = csv.writer(self.__hfd, dialect=self.format)
				self.__fd.writerow(["###Automatically generated by uniPRCsim###"])
				self.__fd.writerow(["###     Version 0.01.01 (preAlpha)     ###"])
				self.__fd.writerow(["###       Watch % 18s     ###"%self.watch])
		def writeheader(self,body,attr={}):
			if self.format == "xml":
				line = "<header "
				for atr in attr.items():
					line += "%s=\"%s\" "%atr
				line += ">"
				for bdy in body:
						line += "%s,"%bdy
				line = line[:-1] + "</header>\n"				
				self.__fd.write(line)
			elif self.format == "data":
				line=""
				if attr.get("time",0):
					line += "time"
					del attr["time"]
				for atr in attr.items():
					if atr[0] == "time" : continue
					line +=" "+atr[0]
				for bdy in body:
					line +=" "+bdy
				self.__fd.write(line+"\n")
			else:
				line=[]
				if attr.get("time",0):
					line.append("time")
					del attr["time"]
				for atr in attr.items():
					if atr[0] == "time" : continue
					line.append(atr[0])
				for bdy in body:
					line.append(bdy)
				self.__fd.writerow(line)
		def write(self, body,attr={}):
			if self.format == "xml":
				line = "<sample "
				for atr in attr.items():
					line += "%s=\"%s\" "%atr
				line += ">"
				if self.watch == "spikes":
					for bdy in body:
						line += "%d,"%bdy
				else:
					for bdy in body:
						line += "%g,"%bdy
				line = line[:-1] + "</sample>\n"
				self.__fd.write(line)
			elif self.format == "data":
				line=""
				if attr.get("time",0):
					line="%7.5f"%attr["time"]
					del attr["time"]
				for atr in attr.items():
					if atr[0] == "time" : continue
					line += " %7.5f"%atr[1]
				if self.watch == "spikes":
					for bdy in body:
						line += " %d"%bdy
				else:
					for bdy in body:
						line += " %g"%bdy
				self.__fd.write(line+"\n")
			else:
				line=[]
				if attr.get("time",-1) >= 0:
					line.append(attr["time"])
					del attr["time"]
				for atr in attr.items():
					if atr[0] == "time" : continue
					line.append(atr[1])
				for bdy in body:
					line.append(bdy)
				self.__fd.writerow(line)
			
		def close(self):
			if self.format == "xml":
				self.__fd.write("</data>")
				self.__fd.close()
			elif self.format == "data":
				self.__fd.close()
			else:
				self.__hfd.close()
	def __init__(self, mode="STD", attr={}):
		if(not attr.get("version", 0) ) or attr["version"] != "0.1":
			if mode == "STD":
				sys.stderr.write("Wrong model forman\nABORT\n\n");
				sys.exit(1)
			else:
				self.error = "Wrong model forman\nABORT\n\n"
				return
		self.object = "model"
		self.objlst={}
		self.workobj=None
		self.maxspikes=-1
		self.elapsed_time=0
		self.timetospike=0
		self.runer_flg = 1
		self.cnt	= 0
		self.name = "collapse"
		self.tos_accomul=0
		self.hideout = 1
		self.mode = mode
		self.error = None
		if attr.get("name"):
			self.name = attr["name"]
	def startpoint(self,object,attr):
		if self.workobj == None and object == "simulation":
			if attr.get("maxspikes"):
				self.maxspikes = float( attr["maxspikes"] )
			if attr.get("SEED"):
				rnd.seed( float( attr["SEED"] ) )
			else:
				rnd.seed(time.microsecond)
			self.workobj = "simulation"
			return
		elif self.workobj == None and object == "output":
			if not self.objlst.get("outputs",0):
				self.objlst["outputs"]=[]
			self.objlst["outputs"].append(clmodel.file(attr))
			self.workobj = "output"
			return
		elif self.workobj == None and object == "prc":
			self.workobj = clprc.clprc(object,attr)
			if not self.objlst.get("prc", 0):
				self.objlst["prc"]={}
			self.objlst["prc"][self.workobj.name]= self.workobj
		elif self.workobj == None and object == "rprc":
			self.workobj = clrprc.clrprc(find=self.find,attr=attr)
			if not self.objlst.get("prc", 0):
				self.objlst["prc"]={}
			self.objlst["prc"][self.workobj.name]= self.workobj
		elif self.workobj == None and object == "population":
			self.workobj = clpopulation.clpopulation(attr=attr)
			if not self.objlst.get("neurons", 0):
				self.objlst["neurons"]={}
			self.objlst["neurons"][self.workobj.name]= self.workobj
		elif self.workobj == None and object == "neurons":
			self.workobj = clneurons.clneurons(attr=attr)
			if not self.objlst.get("neurons", 0):
				self.objlst["neurons"]={}
			self.objlst["neurons"][self.workobj.name]= self.workobj			
		elif self.workobj == None and object == "noisyneurons":
			self.workobj = clnoisyneurons.clnoisyneurons(attr=attr)
			if not self.objlst.get("neurons", 0):
				self.objlst["neurons"]={}
			self.objlst["neurons"][self.workobj.name]= self.workobj			
#DB>>
		elif self.workobj == None and object == "repeaters":
			self.workobj = clrepeaters.clrepeaters(attr=attr)
			if not self.objlst.get("neurons", 0):
				self.objlst["neurons"]={}
			self.objlst["neurons"][self.workobj.name]= self.workobj			
#<<DB
		elif self.workobj == None and object == "connection":
			self.workobj = clconnection.clconnection(find=self.find,attr=attr)
			if not self.objlst.get("connections", 0):
				self.objlst["connections"]={}
			self.objlst["connections"][self.workobj.name]= self.workobj						
		elif self.workobj != None:
			self.workobj.startpoint(object,attr)
		else:
			if self.mode == "STD":
				sys.stderr.write("Unexpected tag <%s> in <model> expression\nABORT\n\n"%object);
				sys.exit(1)
			else:
				self.error ="Unexpected tag <%s> in <model> expression\nABORT\n\n"%object
	def stoppoint(self,object):
		if self.workobj != None and self.workobj == "simulation" and object == "simulation":
			self.workobj = None
		elif self.workobj != None and self.workobj == "output" and object == "output":
			self.workobj = None
			return
		elif self.workobj != None and object == "rprc":
			self.workobj = None
		elif self.workobj != None and self.workobj.object == object:
			self.workobj = None
		elif self.workobj != None:
			self.workobj.stoppoint(object)
		else:	
			sys.stderr.write("Unexpected close tag <%s> in <model> expression\nABORT\n\n"%object);
			sys.exit(1)
	def find(self,object="",name=""):
		if object == "" :
			for objs in self.objlst.items():
				return self.find(objs[0],name)
		elif self.objlst.get(object) and self.objlst[object].get(name):
			return self.objlst[object][name]
		else:
			if self.mode == "STD":
				sys.stderr.write("FATAL ERROR: Cannot find object <%s name \"%s\" >\nABORT\n\n"%(object, name) );
				sys.exit(1)
			else:
				self.error ="FATAL ERROR: Cannot find object <%s name \"%s\" >\nABORT\n\n"%(object, name)

	def write(self):
		lines=["<model name=\"%s\" version=\"0.1\" >"%self.name]
		for i in self.objlst["prc"].items():
			map(lambda x: lines.append("\t"+x), i[1].write() )
		for i in self.objlst["neurons"].items():
			map(lambda x: lines.append("\t"+x), i[1].write() )
		for i in self.objlst["connections"].items():
			map(lambda x: lines.append("\t"+x), i[1].write() )
		lines.append("</model>")
		return lines

	def run(self):
		neuronlst	= self.objlst["neurons"]
		neuronlst 	= [ x[1] for x in neuronlst.items() ]
		connectlst	= self.objlst["connections"]
		connectlst	= [ x[1] for x in connectlst.items() ]
		self.print_header(neuronlst,connectlst)
		self.timetospike = 1e19
		
		for tos in reduce(lambda y,x:y+x.timetospike,neuronlst + connectlst ,[]):
			if tos < self.timetospike:
				self.timetospike = tos
		self.cnt = 0
		self.runer_flg = 1
		while ( self.cnt < self.maxspikes or self.maxspikes < 0 ) and self.runer_flg:
			if self.hideout: self.cnt += 1
			for idx in neuronlst :idx.calculate(self)
			for idx in connectlst:idx.calculate(self)
#			for idx in xrange( len(neuronlst) ):
#				neuronlst[idx].calculate(self)
#			for idx in xrange( len(connectlst) ):
#				connectlst[idx].calculate(self)
			self.timetospike = min(reduce(lambda y,x:y+x.timetospike,neuronlst + connectlst ,[]))
#			self.timetospike = 1e19
#			for tos in reduce(lambda y,x:y+x.timetospike,neuronlst + connectlst ,[]):
#				if tos < self.timetospike:
#					self.timetospike = tos
			if self.timetospike < 0.0 :
				#print reduce(lambda y,x:y+x.timetospike,neuronlst + connectlst ,[])
				if self.mode == "STD":
					sys.stderr.write("At t=%g Minimal Time To Spike less then ZERO!\nABORT\n\n"%self.elapsed_time)
					sys.exit(1)
				else:
					self.runer_flg = 0
					self.error = "\nMinimal Time To Spike less then ZERO!\nABORT\nt = %g\n\n"%self.elapsed_time
					break

				

			self.print_preupdate(neuronlst,connectlst)
			self.elapsed_time += self.timetospike
			
			for idx in neuronlst : idx.update(self)
			for idx in connectlst: idx.update(self)
			self.print_postupdate(neuronlst,connectlst)

		if self.runer_flg == 0: return
		for fl in self.objlst["outputs"]:
			if fl.watch != "last period":
				fl.close()
			else:
				wrd = []
				for  item in neuronlst:
					for ph in item.neurons:
						wrd.append(ph[2])
				fl.write(wrd)
				fl.close()
		self.runer_flg = 0
		
	def print_header(self,neuronlst,connectlst):
		for fl in self.objlst["outputs"]:
		#print fl.name," ",fl.watch," ",fl.format," "
			wrd=[]
			if fl.watch == "time to spike" or fl.watch == "spikes":
				if fl.connections != "off":
					for  item in neuronlst+connectlst:
						wrd += item.getnames()
				else:
					for  item in neuronlst:
						wrd += item.getnames()
			else:
				for  item in neuronlst:
					wrd += item.getnames()
			fl.writeheader(wrd,attr={"time":1.0,"mintos":0})
		
	def print_preupdate(self,neuronlst,connectlst):
		for fl in self.objlst["outputs"]:
		#print fl.name," ",fl.watch," ",fl.format," "
			wrd=[]
			if fl.connections == "off" and (not self.hideout):continue
			if fl.watch == "last period" or fl.watch == "spikes" :
				continue
			elif fl.watch == "time to spike":
				if fl.connections == "off":
					for  item in neuronlst:
						for tos  in item.timetospike:
							wrd.append(tos)
				else:
					for  item in neuronlst+connectlst:
						for tos  in item.timetospike:
							wrd.append(tos)
			elif fl.watch == "phases":
				for  item in neuronlst:
					for ph in item.neurons:
						wrd.append(ph[0])
				if fl.connections == "on":
					for  item in connectlst:
						for ph in item.fifo:
							if len(ph) > 0:
								wrd.append(ph[0])
							else:
								wrd.append(1e19)
			elif fl.watch == "second correction":
				for  item in neuronlst:
					for ph in item.neurons:
						wrd.append(ph[1])
			elif fl.watch == "periods":
				for  item in neuronlst:
					for ph in item.neurons:
						wrd.append(ph[2])
			elif fl.watch == "intrinsic period" :
				for  item in neuronlst:
					if item.object != "noisyneurons":
						wrd += [ item.period for x in xrange(item.number) ]
					else :
						wrd += item.periods
#					print fl.name," ",fl.watch," ",fl.format," ",wrd
			fl.write(wrd,attr={"time":self.elapsed_time,"mintos":self.timetospike+self.tos_accomul})
	def print_postupdate(self,neuronlst,connectlst):
		self.hideout = reduce(lambda x,y:x+y,reduce(lambda x,y:x+y.op,neuronlst,[]),0)
#		print "TOS %g Hide %d Comulation %g"%(self.timetospike,self.hideout,self.tos_accomul)
		for fl in self.objlst["outputs"]:
			wrd = []
			if fl.connections == "off" and (not self.hideout):continue			
			if fl.watch == "last period" or fl.watch == "time to spike":
				continue
			if fl.watch == "phases" or fl.watch == "second correction":
				continue
			if fl.watch == "periods" or fl.watch == "intrinsic period"  :
				continue
			if fl.connections == "off":
				for  item in neuronlst:
						for op  in item.op:
							wrd.append(op)
			else:
				for  item in neuronlst+connectlst:
						for op  in item.op:
							wrd.append(op)
			fl.write(wrd,attr={"time":self.elapsed_time,"mintos":self.timetospike+self.tos_accomul})
		if self.hideout:
			self.tos_accomul = 0.0
		else:
			self.tos_accomul += self.timetospike
		
